# Introduction
In today's digital era, instant messaging platforms have become integral to daily communication. To ensure the communication security, many users prefer to explore any secure communication software as their chat preferences. The popular choices are WhatsApp, Facebook Messenger and iMessage, which provides end-to-end encryption features supported by a variety of protocols. [https://security.apple.com/blog/imessage-pq3/] 
[https://about.fb.com/news/2024/03/end-to-end-encryption-on-messenger-explained/]

Meanwhile, in People's Republic of China(PRC), people cannot find a secure way to communicate. The secure apps we mentioned are not accessible due to the government applied internet restrictions. Instead, in the Chinese market, among all the communication applications and platforms, WeChat stands out with over 1 billion daily active users, making it a dominant force in the messaging area.  However, compare to their competitors on the global market, we found none of the Chinese apps provides an End-to-End Encryption(E2EE) feature, and none of them seen security and communication safety as their priority. This reveals a serious fact, which is over a billion users daily conversation is not protected and fully exposed to the company or the government. 

Therefore, we are here to introduce an E2EE solution for WeChat with main focus on Windows and Android platforms. The whole design has a tested workflow. Although it might not be a production level product to last decades, it potentially benefits people who can only access to the mainland chat applications and the people who need to keep contact with mainland friends, and this idea may incentivizes more similar applications and urge WeChat and the government policies to change. 

We have named this application "Libre Chat" to reflect the freedom and privacy it aims to provide to users who are currently deprived of secure communication options.
# Background and Research
## E2EE Measures from a Global Perspective
There are four properties are used to ensure the messaging is secure, which are confidentiality, integrity, authentication and non-repudiation. [TODO PDF Ref1] There are many encryption protocols are designed to fulfil the these properties, such as Signal protocol and the RSA protocol. 

iMessage, WhatsApp and Zoom provides a default E2EE or provides a E2EE option. iMessage uses PQ3 protocol, WhatsApp and Signal uses Signal protocol. Telegram uses MTProto Protocol. Proton Mail uses RSA protocol. [TODO PDF Ref1]

Thus that, we can generally consider that E2EE is widely used outside internet restricted area. 
## Current WeChat Encryption Measures
According to the official website of WeChat help centre, WeChat uses TLS encryption to secure your data as it moves to and from the servers. For the static data, it uses 256 digits AES encryption. However, during this process, the encryption key is controlled by service provider, Tencent, which means it has a potential threat that Tencent has access to your information and conversation. [TODO https://help.wechat.com/cgi-bin/micromsg-bin/oshelpcenter?opcode=2&plat=1&lang=en&id=1208117b2mai1410243yyQFZ&Channel=helpcenter]

## WeChat Scandal
Above, we talked about the potential technical possibility of WeChat technology. In fact, there are already reports regarding the block and filter of messages of WeChat. It also applies the account ban on sensitive politic messages. 
According to Citizen Lab of the University of Toronto, [TODO https://citizenlab.ca/2020/05/wechat-surveillance-explained/] if a message is censored, it will not notify either the sender and the recipient. For example, in this context example, a user tries to send a sensitive word Dharma Wheel, it will be shown as 'sent' on sender's side and will not be shown on recipient side. 
For text, they use keywords to find sensitive words. For picture, they compare the whole picture with the MD5 hash value with the ones they identified as politics sensitive. In recent years, WeChat also apply the filtering with Optical character recognition(OCR). 

In this article here, it also investigates the picture live detection is based on automatic detection and audit. The audit is based on the OCR of the target photo and compare with the sensitive photo's data. It creates a hash index to achieve the filtering, and the hash index is generated by the MD5 value. It proves that the government would filter the political sensitive information.  [TODO https://citizenlab.ca/2019/07/cant-picture-this-2-an-analysis-of-wechats-realtime-image-filtering-in-chats/]
## Current Solutions
### Substitution Words
For some users, utilizing VPN proxies is not a viable option. Generally, it is not ideal to cite individual cases, but I feel compelled to mention my father. He is unfamiliar with using VPNs but is acutely aware of the restrictions on free speech. He knows that these restrictions can lead to the suspension of crucial social account, WeChat. In response, he continuously avoids using sensitive words, often substituting them with alternative letters. However, with advancements in AI technology and the expansion of keyword databases, even these substituted letters are increasingly subject to censorship. Consequently, certain letters can no longer be used, as they too are being filtered out. [https://www.comparitech.com/blog/vpn-privacy/china-surveillance-censorship/] [https://github.com/citizenlab/chat-censorship]
### Virtual Private Network (VPN)
One popular practice is to use a VPN to access software outside the country to obtain end-to-end encryption. But this approach has many drawbacks.

First, the security of communication between users and VPN service providers is not necessarily guaranteed. Currently, the larger VPN providers, such as NordVPN, Express VPN, are blocked by the government, and their connection speeds are slow and very unstable. Some users choose smaller VPN providers, they usually have a smoother experience, but many providers do not have relevant service qualifications, and do not have formal business registration in any country, so the risk may be greater.

Second, VPN services are essentially in violation of relevant Chinese laws and regulations. Chinese laws and regulations stipulate that only enterprises can apply for the use of international communication channels, and individuals generally have limited requirements for application and are unlikely to be approved.

Third, the use of VPN is not convenient. If we are always connected to VPN, some software cannot be used. For example, the access speed of government affairs software, enterprise information query software and all kinds of WeChat mini programs will become very slow. [https://nordvpn.com/blog/vpn-for-china/]     [https://www.privacyaffairs.com/are-vpns-legal-china/]     [https://www.t3.com/features/do-vpns-work-in-china-and-are-they-illegal] 
[https://www.vpnmentor.com/blog/expressvpn-works-in-china-but-only-if-you-do-this/]
\
### E2EE Deprecated Solutions for WeChat
In the past, there are some open source solutions attempt to use web version of WeChat to intercept the messages. It avoids the complexity of reverse engineering. However, as WeChat aware of the potential use of WeChat Web version, they are forcing users to switch to WeChat Desktop version. Therefore, the web version's use becomes very limited. [https://github.com/ygcaicn/wx_e2e]

# User Manual and Demonstration
## Windows

The whole video demonstration could be found here. [TODO YOUTUBE] 
### Basic Function Page [TODO PHOTO] 

The Basic Function Page provides users with a foundational set of cryptographic operations, allowing them to experiment with essential features. This page includes several key-related functionalities:

1. **Key Operations**: Users can generate, update, copy, and paste cryptographic keys. Additionally, the page supports key import functionality.
2. **Key Storage**: Users can store and manage other users' public keys by importing them into the system.
3. **Instant Encryption/Decryption**: The page enables real-time encryption and decryption operations, utilizing others' public keys in conjunction with the user's private key.

### WeChat Direct Message Page [TODO PHOTO]

The WeChat Direct Message Page outlines the mandatory steps required to integrate and utilize WeChat for secure communications. Users must complete the following steps:

1. **WeChat Setup**: Install WeChat and add the WeChat Anti-Update Plugin.
2. **Hook WeChat**: The page offers a crucial function to hook WeChat, enabling secure interactions. Upon completing these steps, users can proceed to the subsequent subpages.

### WeChat Communication Channel Build Page [TODO PHOTO]

The WeChat Communication Channel Build Page guides users through establishing a secure communication channel within WeChat. The process involves the following steps:

1. **Hook WeChat**: Both users must hook WeChat to prepare for secure communication.
2. **Temporary Encrypted Chat**: 
   - The first user selects "Listen for a Temporary Encrypted Chat" after hooking WeChat.
   - The second user, after hooking WeChat, chooses "Start a Temporary Encrypted Chat." This action transitions the first user to the Secret Chat Page.
3. **Key Exchange**: On the Secret Chat Page, the first user sends their key to initiate the secure chat, allowing the second user to enter the same encrypted session.

### Secret Chat Page[TODO PHOTO]

The Secret Chat Page facilitates secure messaging by leveraging each user's public key alongside their private key. This page automates the process of sending and receiving encrypted messages, ensuring secure communication between users.

## Android
The video demonstration can be accessed here. [TODO Video]
### Create User [TODO PHOTO]
The create user function initiates when the app starts. It will generate a secret key for both the sender and the receiver. 
### Send Public Key [TODO PHOTO]
### Select Other User 

### Encryption 
After the user click on the encryption message, the user could see their encrypted message. 
[TODO PHOTO BEFORE Encryption]      
[TODO PHOTO AFTER Encryption]
### Decryption 
After the user click on the decryption message button, the user could see their decrypted message. [TODO PHOTO FOR DECRYPTION]
# Develop Structure 

## Windows
Our app targets to make use of the open source WeChat hook to intercept the incoming WeChat messages, and send encrypted outgoing messages. During this process, RSA will be used as the main protocol to ensure the E2EE communication. Below is a summarization of the development chart. 
[TODO Windows Dev Chart Here]
![[Pasted image 20240825210233.png]]
### Underlying Technology
The underlying technology behind the WeChat injector is a sophisticated application of reverse engineering. The original author developed this tool from a publicly available GitHub repository. The process uses Cheat Engine to find the offset of the certain functions, such as send message and receive message functions, then they can accept the inputs from the users, and forward the received messages to the corresponding port. It monitors the WeChat process, specifically targeting the sending of messages and setting breakpoints. This allows for the identification of the corresponding assembly code responsible for these actions. Subsequently, APIs are established to leverage this assembly code for sending and receiving messages.

Additionally, the injector exploits a vulnerability in SQLite3. SQLite3 is used to maintain compatibility, with its API designed for downward compatibility. The approach involves using the `sqlite3_close` function as an anchor to locate other functions, based on the assumption that their offsets will remain consistent. This method allows for the systematic identification and utilization of various SQLite3 functions by referencing their fixed offsets.
[https://github.com/ttttupup/wxhelper]

### General Structure
#### MERN Stack
In our application, the whole application is designed following the usual MERN (MongoDB, Express, React and Node) based structure. We applied this structure with an Electron based app. The similarity between MERN stack and Electron means it is possible for a single full stack developer to create, design and build the whole application without the need of knowing much about traditional Windows development tools. Both of them use Node.js as the backend and React.js as the frontend. Besides, it maintains key features as the desktop node, which means it could interact with the files to inject WeChat, create local database to save keypairs and make use of the WeChat hook, while keeping connection with the local APIs. [https://blog.logrocket.com/mern-stack-tutorial/]   [https://scientyficworld.org/mern-stack-app-with-mongodb-express-react-node/]
[https://www.bezkoder.com/react-node-express-mongodb-mern-stack/]

#### NeDB
Similar to MERN stack, we choose NeDB as our local database. Compare to MongoDB, it is a light-weighted database without the requirement of individual database server and more common for a DB that only serves a single process. It keeps the NoSQL DB feature and uses the query commands that are similar to MongoDB. 

#### Inter-Process Communication
Although the Electron application is easy to develop, it does not force the application to use their best practices. It includes many unsafe features that might harm the user benefits. It allows direct calls between the frontend and backend process, which means that the developers might unintentionally create vulnerability between the frontend process and the main process. 
To avoid this security issue in our security-based application, we have utilized a architecture that isolates the backend Node.js environment from the frontend by utilizing secure IPC calls. The aim of this feature is to enhance the security by ensuring that communication between the frontend and backend is tightly controlled and monitored. 
IPC calls provide a secure channel for data exchanges, minimizing the attack surface by preventing direct access to the backend processes. The isolation helps us to protect sensitive backend operations, such as the key operations from potential threats from the frontend user interface. Besides, the IPC calls allows us to enforce strict access controls and validation mechanisms, which ensures that only our frontend could access our backend. 
Therefore, although this feature might increase our development complexity, we still utilized this feature to ensure the best practice. [https://www.electronjs.org/docs/latest/tutorial/security]
[https://node-security.com/posts/secure-electron-ipc/]
[https://blog.logrocket.com/electron-ipc-response-request-architecture-with-typescript/]
[https://blog.logrocket.com/handling-interprocess-communications-in-electron-applications-like-a-pro/]
[https://blog.core.ai/blogs/secureelectron/]

#### Assets Management
During the development process, since there are many additional plug-ins, including the WeChat installer, the Injection Tool, the dll and bat files, it is hard to determine where we should store these hundreds of MBs data. When considering the inclusion of additional assets into the Electron Builder installer, two primary approaches are considered and, each with distinct advantages and challenges.
##### GitHub Contents
The first method involves hosting the assets on GitHub Contents or a similar global content delivery network (CDN), from which the installer fetches the required files during the installation process. This is widely used by multiple start up companies, and I initially learned this from Solana's metadata program. 

This approach significantly reduces the overall size of the installer, which can be particularly advantageous for applications that allow free international download, where minimizing download times and storage requirements is essential. However, this method poses significant accessibility issues, particularly for users in regions like China, where access to GitHub and other foreign CDNs is often restricted. As a result, the user experience in these regions can be severely degraded, leading to potential dissatisfaction and higher abandonment rates during installation.
##### Server Host
The alternative approach involves hosting the assets on servers located within China, which would ensure faster and more reliable access for users in this region. While this solution effectively addresses the accessibility issues encountered in the first approach, it introduces the risk of the server being targeted or blocked by Chinese authorities, particularly if the content or the hosting platform is deemed sensitive or non-compliant with local regulations. Moreover, managing a separate server infrastructure adds operational complexity and potential security vulnerabilities, as the server must be maintained, monitored, and protected from attacks or misuse. 
##### Embed to Installer
Given these considerations, I ultimately decided to embed the necessary assets directly into the installer by modifying the Electron Builder configuration. This approach, while increasing the size of the installer, guarantees that all users, regardless of their geographical location, have consistent and reliable access to the required assets. By including the assets in the installer package, I mitigate the risks associated with external dependencies and ensure that the installation process remains seamless and efficient across all user environments. 
However, this would still be a challenge for us to manage the installer size. [https://www.electron.build/configuration/nsis.html]
#### Others
During the development process, we finally choose `npm` as our package management software, because of its reliability compared to yarn. 

### Back End
The backend maintains the communication between DB and utility tools including the WeChat installer (for people to easily install WeChat) and the Injection Tools (to make use of the WeChat hook to inject WeChat). It also provides the encryption, decryption and generate keypair function to the front end. 
#### Keys and its exchange
##### Security
Security is the core requirement of key exchange. During the key exchange process, potential Man-in-the-Middle attacks need to be prevented to ensure that only the communicating parties can obtain the shared key. Common encryption protocols, such as Diffie-Hellman and RSA, provide some degree of resistance to man-in-the-middle attacks. 
##### Key Formatting
In practice, key formatting is an aspect that needs special attention in the process of key exchange. Keys often need to be transferred and stored between different systems, so they must be in a format that is common and easy to parse. Common key formats include PEM and DER, which are standard key encoding formats to ensure that the key can be recognized and used by different applications.

In our project, RSA algorithm is used for key exchange, and 2048 bit length key is selected, and OAEP (Optimal Asymmetric Encryption Padding) is used. The choice was not random, but was made after careful consideration. RSA-2048 provides enough security to protect against currently known computing attacks. The key length of 2048 bits still has high security under modern computing power, and can effectively prevent brute-force attacks. In addition, OAEP filling mode is one of the widely accepted filling schemes at present, which provides the randomization of ciphertext, thus enhancing the security of ciphertext and further improving the anti-attack capability.
##### Algorithm and Padding

RSA algorithm is widely introduced in our security course. It is an asymmetric encryption algorithm, which realizes secure communication through public key encryption and private key decryption. In RSA algorithm, the key length is a key parameter, which directly affects the security and efficiency of encryption. The RSA key length of 2048 bits has been generally accepted in modern applications to provide sufficient security while being computatively acceptable to most devices.

OAEP was chosen as the fill mode for a number of reasons. First, OAEP mode combines plaintext with random numbers to generate a pseudo-random ciphertext, thus preventing attackers from inferring the original data by analyzing the ciphertext pattern. Second, the OAEP pattern also has semantic security, even in the absence of a key, the attacker cannot infer anything about the plaintext from the ciphertext. Compared with the traditional PKCS#1 v1.5 padding scheme, the OAEP padding scheme has significant security advantages, especially in the face of ciphertext analytic-based attacks.

##### JSON Formatting
JSON formatting helps improve the portability and compatibility of the key exchange process. By encapsulating the key and its associated metadata in a JSON object, you can ensure that the key remains consistent during transmission and storage between different systems. It provides a standardized way to represent and transmit data. Common string format is often difficult to deal with complex data structures, which easily leads to parsing errors or data loss. The structured nature of JSON format effectively avoids these problems and ensures the accuracy and reliability of key exchange.


##### Man in the Middle Attack
The JSON file need to be 

#### Anti-Update Bat
When we study the automatic update mechanism of Wechat client, we find that its update process mainly depends on the configuration of system registry and local files. Wechat determines whether updates are needed through specific items in the registry, and saves relevant update data and patch files locally. Therefore, by manipulating these configuration items and files, you can effectively prevent the automatic update behavior of the wechat client.

Specifically, WeChat's `NeedUpdateType` item under the registry path `HKEY_CURRENT_USER\Software\Tencent\WeChat` determines whether the client needs to be updated. When the value of this item is set to 0, wechat will not trigger the update request. In addition, WeChat saves the update.data file in the local directory `%USERPROFILE%\AppData\Roaming\Tencent\WeChat\All Users\config`, which is used to record update status information. By deleting the file and recreating an empty file, while limiting write permissions to the file, you can effectively prevent wechat from updating itself during subsequent startup processes.

Similarly, WeChat saves the update patch file in the directory `%USERPROFILE%\AppData\Roaming\Tencent\WeChat\patch`. By deleting the directory and recreating an empty directory with restricted access, wechat can be prevented from downloading and applying new patches from the server.

To sum up, the update behavior of the wechat client can be effectively controlled through the operation of registry entries and local update files. This is the foundamental to keep our software to support a long term use without influenced by the WeChat update. 

#### APIs/Different Languages
Since we are using multiple plugins including the wxhelper inject code, its Java API code and so on, so it requires the communication between different modules through APIs and JSON responses.

#### Install WeChat
To avoid manual processes, we implemented multiple scripts to streamline the user experience. These scripts are executed using Node.js's `child_process` module, allowing for seamless automation of tasks. By leveraging `child_process`, we can run shell commands directly from the Node.js environment, which helps in automating the installation of WeChat.

#### Injection Tools
Injection tools are initially the first step to determine if the project could succeed. Due to different devices have different hardware structures, here we could only use a generic injector that could perform the injection on different devices without letting the WeChat crash. [https://github.com/nefarius/Injector] 

#### Express Server vs. netcat
### Front End
On the front end, tailwind CSS is used to design the scope and to perform simple animations. 
#### UI Design

#### Functionality
React is used to make the front end componentized. 
We applied React Context to continuously read the content and share the chat messages history among all React front end pages. It is also used to keep the front end state. It provides the injection page, encryption decryption page, and the chat page to the users. 

#### React Context
In our application, we use **React Context** to efficiently manage and share the received WeChat messages across all pages. React Context provides a powerful and flexible way to propagate data through the component tree without having to pass props manually at every level. This is particularly useful for global data like WeChat messages, which need to be accessible in various components of the application. 
There are a few components. The first part is the context. It can create a context to provide the message status and management functions. The second part is the provider, which could have useState or useReducer to manage the message status. When the hook receives a new WeChat message, the provider will refresh the status in the context, and all the components 
## Android

[TODO Android Dev Chart Here]
![[Pasted image 20240825210317.png]]
On Android side, our original plan is to integrate and inject WeChat injection tools again to our Android devices, but usually the Android devices have a more strict control over the apps. Therefore, to inject WeChat, a rooted device is required for users to use the app. However, our previous main goal is to provide a general solution for the non-tech people, but rooting devices requires the users to have a deeper understanding in Android. Therefore, we decided to make a supplementary solution for the mobile device. This solution is more likely to be a support tool to the main Windows software. 

The key idea of this app is to design a keyboard app, which allows users to save multiple keypairs, and create their own keypair. They can encrypt and decrypt the messages while sending and receiving text messages without rooting their devices. 

During the Master's degree period, it is almost impossible for a student to design an easy-to-use input method to be competitive as the main Chinese competitors like Sogou and Baidu. But recently in April 2024, the citizen lab published another article regarding the Chinese input methods, in this report, almost all the keyboards app have potential vulnerabilities.  Therefore, we had to search on the GitHub and finally chose Fcitix5 for Android as our choice. It is open source, offline, and has a wide range of users, and relatively easy to modify. 

The project is a Kotlin based software and can support java integration. 
### Structure
The main code structure follows the original keyboard pattern, as we want to keep its keyboard functionality as much as possible. 

We created a new set of data in shared preferences to store user private key and user public key, as well as friend public keys, so we can store the information without the information being read by third party apps. We also used the Room Database to monitor the clipboard. 

The controllers can generate keypairs, add contact public keys, and decrypt/encrypt the messages. It also communicates with the Java encryption modules. 

The front end consists of the nickname input, and a top bar consists utilizing these features. 


# Solutions and Issues
The overall result demonstrate how the secret channel between two users are build, but unfortunately with only me as the developer, it is hard to 

## Solved Issues 
### Photo Hook
In this development, what bothers me the most is the hook of the picture. I tried many ways to hook encrypted images, i.e., files, but ultimately failed.
The first thing I checked was that there was an internal problem with the API. I looked at the wxhelper code to try to determine if there was an internal problem with the Java file, but I didn't find any problems afterwards. The API provided by the Java file returns the correct response, but there is no way to download the correct file with the MsgID. After that, I tried to use other tools, such as verifying that the result of finding call in C language is correct, but I didn't find any problems. In the end, I can only judge that there are some problems in Wechat, which lead to the MsgId cannot correspond to the files in the database, so I cannot get this picture. 
#### Alternative Solution 
With this in mind, I consulted other members of the Telegram Community and they gave me some advice. They told me that wechat can automatically download a certain volume of files, and this file can automatically receive files sent by others. I took his advice, but I found it unstable. Receiving files under 200MB function itself is good, but it is not as good as a assured function or API. Even though I know from the message that it is downloading a file, it is not possible for me to treat it like an async function or API, that means it is impossible for me to know when will the file be finally received. I can add some error handling in the code, and create a loop and set a interval to keep checking if the local folder receives the code, but ll I can do is keep using the interval function to try to get the file, and it may cause the infinite loop to exist.
#### Final Solution
Finally, after many attempts, I still couldn't find out why MsgID couldn't be used to get files. After many attempts, I posted the question again to the Telegram Community group, and this time luckily, the wxhelper writer replied and provided me with a link to his previous answer to someone else for free. His basic idea is to provide an error on Big Int Conversion, and he thinks that I may have a problem with type conversion due to Big Int. 

##### Verify and try
In order to verify his claim, I tried to build a Python flask server and another Electron express server. I watched both servers react by sending them the same JSON formatted string containing a long int, and the result was that Node.js couldn't handle the Big Integer conversion. At the same time, I used different WeChat messages again to check their status, and I found that Python could handle MsgID correctly, and the obtained MsgID could be used as WeChat files, while the Node.js server could not. 

The deep reason is that JSON parse function in node.js is never designed to decode any BigInt values, the community has made a separate JSON parse designated for the large integers, which is called json-bigint. After I fully switched to this new version of parsing algorithm, the issue got resolved. 


### Limited Senior Develop Resources
During the development process, several issues can cause progress to stall. As a junior developer, encountering specific problems often leads to confusion and difficulty in finding solutions. While resources such as Stack Overflow and ChatGPT provide some assistance, they cannot fully replace the guidance of senior developers. This projectâ€™s complexity, involving the integration of front-end, back-end, and an injector, poses significant challenges. The solution of this would be better to improve myself, during the past 4-month work at Koii Network, I have learned a lot of Electron development skills . 

### New Language, Junior Developer

Another challenge is working with an unfamiliar programming language. Although I am proficient in web application development using Electron, I opted to develop a keyboard app, which necessitates the use of Java-Kotlin with Android Studio due to the inadequacy of React Native for this purpose. My limited experience with Java-Kotlin adds to the difficulty. The solution would be better to learn Java and Kotlin skills from all the resources, including Stack overflow, Cainiao Programming Tutorial and ChatGPT. 


## Unsolved Issues
### Express Server Stall
During the setting up of express server, there is some probability that the express server cannot receive the messages, but all other functions remain in the hook do not have any issue. 


# Project Management
## Concepts Application
For the last several months, I have learned many essential software development skills and applied them to our apps. The app design concepts  are usually a foundation of the whole software development process. 
### Coupling and Cohesion [TODO REF]
The high coupling refers to a situation where modules are highly dependent on each other. It means changing one module might require changes in several other modules as well. The low cohesion means that the functions within a module are not closely related and the module might be responsible for too many unrelated tasks or a module contains too many unrelated functions. The combination of these two issues might lead to code that is difficult to maintain and hard to extend.    
This issue is extremely difficult in Electron, because both frontend and backend code are in JavaScript. It means some functions can be done on the frontend, and they can be done on the backend as well. If the modules are not designed properly, the coupling will be very high. 
To avoid this issue, we follow the module design principle. During the development in Electron development. In the software, we separate the frontend logic and the backend logic. The basic principle is everything related to data will be strictly limited to only be processed on the backend, and everything regarding the interface will be strictly limited to the frontend. Therefore, even if the frontend and the backend changes, they will not influence each other, to afford a low coupling and high cohesion application. 

### Comments Reducing [TODO REF]
Regarding comments, it is really controversy. Many code examples encourage writing clear comments and docs. However, during the development process and the advice of my colleagues, I realized that the code readability is not really achieved by massive comments. It is based on clear and simple naming. When a software is designed in a good structure, the name of the function and the name of the variable could be meaningful and express their utilities. The comments will be redundant and unnecessary. For example, 
```
// The following variable indicates whether WeChat is hooked
let k = false;
```
the above block is not as clear as the below one. 
```
let isHooked = false;
```
Therefore, by applying this rule, we reduced many keys 
### Over Engineering [TODO REF]
Over engineering or early optimization is the mistake I made in this project. At the beginning of the project, we aim too much on designing the folder structure without the real requirement support. The general security standard is too high to ignore the real functionality design. Both resulted the development efficiency is low. 
However, the process finally does provide a relatively clear structure to allow me to extend the code structures. 
## Timeline
Starting from **February 1st**, the primary focus was on the initial phase of **Electron Development** for the dissertation project. This phase involved setting up the foundation for the software, including essential features and core functionalities. Alongside this, I balanced part-time internship responsibilities and class, ensuring progress in both areas.

Moving into **March**, the **Electron Development** continued while maintaining part-time work. The internship provided valuable insights that contributed to the development process, ensuring that the codebase was well-structured and adhered to best practices.

From **April 1st**, the focus shifted to **Android Development**. This phase involved integrating the core features into the Android platform while ensuring seamless performance across devices. The transition from Electron to Android required careful consideration of platform-specific optimizations and user experience design.

As **May** began, the Android development phase continued, overlapping with crucial exam preparations and reviews. Balancing academic responsibilities with the ongoing project work ensured that both aspects were handled effectively.

By **June**, with the exams completed and review sessions behind, the focus returned to the software's final phases of development. **Electron/Injector Development** began in earnest, incorporating the remaining features and preparing the software for rigorous testing.

From **July 10th**, the emphasis was on stabilizing the software, focusing on **Test/Improve** efforts. This phase involved rigorous debugging, refining, and optimizing the code to ensure peak performance and reliability. Extensive internal testing was conducted, including unit tests, integration tests, and system tests, to catch any remaining issues and performance bottlenecks.

As **August** progressed, the software entered its final stages of testing. The external testing phase involved a select group of testers using the software in real-world scenarios. Their feedback was crucial in making any last-minute adjustments or improvements.

Throughout this period, I was on standby to address any issues or feedback swiftly, ensuring the software met all user expectations and performed flawlessly. By the end of **August**, the project was completed, resulting in a robust and reliable product ready for launch.


![[Pasted image 20240825210453.png]]
## Version Control

During this project, we extensively utilized Git as our version control tool. Git's robust branching and merging capabilities allowed for self progress checking, ensuring that code changes could be tracked, reviewed, and integrated efficiently.

## Issue Tracking

To manage and track the progress of tasks and issues, we employed GitHub Issues and Jira. These tools enabled us to create, assign, and monitor issues, facilitating a self-sprint period where tasks were planned, executed, and reviewed systematically. This approach helped in maintaining a clear overview of the project's status and ensured timely resolution of issues.

## Continuous Integration and Continuous Distribution (CI/CD)

To streamline our development process and ensure that our application was always in a deployable state, we implemented a CI/CD pipeline using GitHub Actions. This pipeline was configured to run Electron Builder, a comprehensive tool for packaging and distributing Electron applications, whenever code was pushed to the repository. This automated process ensured that our builds were consistent, reducing the likelihood of human error and speeding up the release cycle.

## Feedback and open-source

Once the reports are submitted and the project has been evaluated, I believe the best path forward is to involve the community. Maintaining this software on my own would be an insurmountable task. Without ongoing maintenance and updates, the software would eventually become obsolete and cease to function effectively.

To address this, I propose open-sourcing the project. By making the code available to the public, we can invite contributions from a diverse group of developers and enthusiasts. This collaborative approach will ensure the software remains up-to-date and continues to improve over time.  

The only concern would be the developer user base, but as we can observe from wxhelper project, I believe some of the developers would like to take part in the project.

Open-sourcing the project will not only facilitate its longevity but also foster innovation. I am eager to see how the community can enhance the project with their feedback, ideas, and contributions. By working together, we can create a more robust and versatile tool that benefits everyone.


## Tools Utilization
## Live Debug
Developing an Electron app is similar to developing the web apps. Usually the web apps could apply the changes of the feature instantly and directly reflect instantly on the webpage. Electron framework inherits the benefits of web development while supporting the desktop app functions with multi-platform support. 
### Code Formatting
To maintain the clarity and maintenance of the code, it's essential to address common issues during coding. Therefore, in our project, I used ESLint and Prettier. ESLint helps in identifying and fixing code quality issues, while Prettier ensures consistent code formatting. By incorporating these tools into our development process, we not only make our code more readable to others but also to ourselves. As the saying goes, "Only God and I know what this code does... and sometimes even I'm not sure!" Proper formatting and linting help ensure that our code remains understandable, even as it evolves over time.

## Beta Test
### Android
#### Testing Plan
We want to invite 10 users to verify the functionality, usability, and security of the Libre Chat Android application, ensuring that it meets the requirements for secure communication via the custom keyboard app. This testing plan covers the key features of the Libre Chat Android app, including key generation, key storage, encryption/decryption of messages, and overall app performance on various Android devices. 

**First Part: Functionality and Compatibility Testing** The first stage of our testing process will focus on functionality and compatibility across a wide range of Android devices. This testing phase is to ensure that the app's core features perform consistently and reliably, regardless of the device's make, model, or Android version. We will conduct thorough tests on various Android versions, from the latest updates to older, more commonly used versions, to confirm that our app maintains its functionality across all platforms. Additionally, we will test on devices with different hardware configurations, screen resolutions, and performance capabilities to identify any potential issues or incompatibilities that could affect user experience. The goal is to guarantee that every user, irrespective of their device or Android version, can fully utilize the app's features without encountering bugs or performance issues.

**Second Part: UI Testing** The second phase will focus on User Interface (UI) testing, where we will evaluate how the app's design and layout adapt to different screen sizes and resolutions. This stage is essential to ensure that the visual elements of the app are responsive and maintain their integrity on a variety of devices, from smaller smartphones to larger tablets. We will examine whether all UI components, including buttons, images, and text, are displayed correctly and are easy to interact with, regardless of the screen size.

The expected testing result would be satisfying all the requirements we mentioned. 
#### Testing Result
During a long term testing, it does meet all the requirements we mentioned above regarding the UIs and the features. 

The good part is there are 6 users finally attend the testing. The testing of the Android devices is great. None of them have any major issues during the Android testing. All the functions are performed perfectly and the onboarding process is smooth and clear. The software is generally stable. It does not crash even once during the testing process. 

However, there are several crucial drawbacks and I will list them from the most crucial one. 

The first one is about the memory. When we send message, there are some probability that sometimes people forgot where the punctuation is. For example, when we write a long sentence "Do you remember last time when we go to the cinema we met a person called Joe? ", we might need to cut down the sentence in the middle to quickly respond to the other user. Usually, during this time, we might forgot where is the punctuation. It would make the sentence is not connected. 

The second one is about the history. When we send some important messages, for example the date and the events, we may need to look them back further. However, it is impossible to look back to all the hash functions and decrypt them all. 

The third one is a bug related to the plaintext. We need to put the marker before the plaintext, before we encrypt the message to make sure that the plaintext  will be deleted after the encryption. This might be an extra step for the users and might be a little bit confusing. 
# Potential Threats
## WXhelper Update
The project WXhelper is maintained by community members. Although the community members are keep contributing the new versions to follow up the WeChat versions, there are some minor changes are every update to make it not fully production reliable and hard to keep consistent update. For example, the API usually update very frequently and does not have a fixed pattern. For example, the type of the API calls route changes from the numeric numbers like `/api?type = 1` to meaning based routes like `/api/hookMessages`. 
It means every time they update their API, we might need to manually update it. That requires a continues distribution which this process can be interrupted by the third party.  

## Potential WeChat Anti-Measures
It is possible for WeChat to block E2EE communications on WeChat. It depends on whether this worth them to do that. 
### Entropy
For example, the message contains encrypted messages usually have a high entropy and looks like random bit stream. WeChat could monitor the messages and identify the high entropy messages and mark them as a strong encrypted messages and may block these high entropy messages as well if they want. 
### Length
Also, since the RSA data length is fixed after the encryption and does not follow the plaintext's length to change. WeChat could also identify if the users have sent the messages of the same length. 
### Deep Packet Inspection
Deep Package inspection could be used to check the transmission of the data packages. It could identify the encryption protocols 

# Unachieved Features
## Multi-language
The multi-language support is the essential requirement for an application that face both Chinese and English users. However, this proposal was considered but finally not achieved. 
The core thing to support multi-language is to use language files, such as JSON or YAML. This contains all the strings that are translatable in the application and will be put in the separate folder to use them. 
However, the development requires some changes on the UI. The UI design will be broke and need to be adjusted after the multi-language is deployed, which is a heavy work for an individual developer to implement. 
Also, during the development of the public apps, even the companies' app cannot achieve the multi-language support. 
## Multi-Platform
### Attempts
#### Unified Format
Initially, we used a conventional method to read file information and messages. This approach involved extracting the corresponding RSA key by checking for keywords in the file. However, we later switched to a unified JSON message format. JSON messages facilitate the transmission of the same information across multiple devices and languages more conveniently, avoiding compatibility issues when facing some special characters, such as the line change character, `\n`.

By adopting a unified JSON format, we were able to streamline communication between various devices, ensuring consistency in the data structure and reducing potential errors caused by language differences. This format also allowed for easier integration with other systems and tools, as JSON is a widely supported and flexible data format. The move towards JSON was a key step in ensuring that our encryption and messaging system could scale and adapt to different environments without sacrificing security or functionality.

#### Key Type and Import
We adopted the same RSA encryption method and settings to ensure that the generated RSA keys are identical. Additionally, I designed a feature that allows the RSA key generated on the mobile device to be imported into the computer. This enhances the synchronization of keys across multiple devices, ensuring that other contacts do not need to store different public keys for different platforms multiple times. The import works for the desktop version, but still doesn't work for the phone version.

This feature was particularly important for maintaining a seamless user experience and is an essential factor for evaluating my project. By allowing RSA keys to be shared and imported across devices, users could avoid the hassle of managing multiple keys for different platforms. The successful implementation on the desktop version demonstrated the feasibility and benefits of this approach. However, the challenges encountered in implementing this feature on the mobile version highlighted some of the limitations and complexities involved, such as differences in operating system capabilities, file handling, and security restrictions on mobile platforms. 

## Jest Testing
As we already discussed that testing is an essential part in the project, and Jest is a powerful testing tool for our project, but we finally only provide some simple examples and unfortunately cannot integrate it further to our project. The reasons are listed below. 
### Data Type
Within the project, the project content gives the Jest testing some challenges. To test with Jest, we need to simulate the real world conditions and give the expected return values to the functions. For example, if we want to test the decryption, we need to give the type of messages will receive on WeChat. However, since there are a various type of the message structures are used in the WeChat, and we cannot get the structures before we were trying in advance. It is impossible to apply a comprehensive and meaningful Jest testing. 
### Code Structure
Currently, within the code, there are a lot of async operations and the APIs of the WXhelper. To configure Jest with WeChat and WXhelper, it requires a lot of additional configurations and the customizations, causing an increase in the test writing and maintenance complexity. 

# Conclusion
In this Dissertation Project, we may not have really in-depth academic research, nor did we try to explore some undiscovered areas. Rather, it's an integration of resources, and by integrating different resources from multiple sources, we've been able to create a new product that no one else has yet created, which hopefully offers a better possibility to allow users of WeChat to have more control over their chat privacy.

Finally, out of selfishness, I prefer to let my project work lose its due role. I hope that WeChat can provide users with native end-to-end encryption in the near future, and the government can introduce corresponding measures to support these moves, which will not only protect the privacy of all users, but also allow people to monitor all aspects of speech to a new height.

# Acknowledgement

First of all, I would like to thank Professor Hao for giving me a lot of support through such an unrealistic dissertation project that does not look like a very formal research.

Secondly, I am very grateful to the wxhelper's author and its community. The author does not only provide a public method to make a WeChat hook, but also gave me a selfless tutoring to resolve the big int issue. 

Then, I would like to thank the fellow leaders at Koii Network, Syed Ghazanfer Anwar and Pablo Poggio, who have taught me Electron and self-motivated problem-solving methods in their work.

Finally, I would like to thank my girlfriend for her support during this process. Many times, I stayed up late to write code after having ideas, which affected his sleep. I also appreciate her tolerance.

# é™„å½•
files
ç”µè„‘ç«¯
æ‰‹æœºç«¯
Pythonæµ‹è¯•
