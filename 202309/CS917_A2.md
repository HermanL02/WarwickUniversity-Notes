# Question 1
| Time   | 1 second | 1 minute | 1 hour | 1 day |
|--------|----------|-----|-----|-----|
| $n \log_{2} n$| 62746 | $2.80*10^6$  | $1.33*10^8$| $2.76*10^9$      |    
| $n^2$ | 1000 | 7746    |  60000   | 293939  |   
| $n^3$|   100  | 391 | 1533| 4421  |    
| $2^n$  |  20        | 26  | 32    | 36    |   
| $n!$  |  9        | 11  |  13  | 14     |   

# Question 2
a. TRUE, because the [Big O notation allows us to express an upper bound on the expected time taken as a function of an input size n](https://docs.google.com/presentation/d/15D6GKSFy_IjbfWUJN2hg47ceoklouHEag7n-rjk6CUs/edit#slide=id.p16),which means for any n, the function's growth rate will not exceed $n^2$ 's multiple. In this case, the leading coefficient is $n^2$. Therefore, it is the upper bound of the expected time, which is $O(n^2)$ . 

b. TRUE, because the Big $\Omega$ notation means [For sufficiently large values of n, the growth rate of f(n) is never less than g(n)](https://docs.google.com/presentation/d/1QqE7X-4YgEPJ2tEFAPW5cKEGJGbwp_EcW6AkKso3Nx0/edit#slide=id.p11) Therefore, in this case, for a sufficient large n value, the $n^4$ is the leading coefficient, and it will not less than g(n). It is quartic. Therefore, the function is in $\Omega(n^4)$. 

c. TRUE, because the [Big O notation allows us to express an upper bound on the expected time taken as a function of an input size n](https://docs.google.com/presentation/d/15D6GKSFy_IjbfWUJN2hg47ceoklouHEag7n-rjk6CUs/edit#slide=id.p16), the function's leading coefficient is $19n^3$ , which is a cubic number, and for a sufficient large n, it cannot exceed the cubit growth rate. Therefore, $O(n^4)$ could be the upper bound for this function. 

d. FALSE, [For sufficiently large values of n, the growth rate of f(n) is the same as the growth rate of g(n), or f(n) is tightly bound by Θ(g(n))](https://docs.google.com/presentation/d/1QqE7X-4YgEPJ2tEFAPW5cKEGJGbwp_EcW6AkKso3Nx0/edit#slide=id.p16)For a sufficient large n, the leading coefficient would be $n^4$. $n^4$ is significantly greater than $n^2$. So, the function is not in $\theta (n^2)$

e. TRUE, because the Big $\Omega$ notation means [For sufficiently large values of n, the growth rate of f(n) is never less than g(n)](https://docs.google.com/presentation/d/1QqE7X-4YgEPJ2tEFAPW5cKEGJGbwp_EcW6AkKso3Nx0/edit#slide=id.p11)Therefore, in this case, for a sufficient large n value, the growth rate is the leading coefficient $n^2$, which is greater than $n$. Therefore, the function is in $\Omega(n)$.   
# Question 3
1. Master Theorem cannot be applied, because a is not a constant. 
2. Since c = 2, $log_a(b) = log_{16}(4) =  1/2$, $c>log_a(b)$
   Therefore, we can apply Case 3. The complexity is $\Theta(n^2)$ by definition. 
3. Since c = 3, $log_a(b) = log_{4}(3/5) = -0.36$, $c>log_a(b)$
   Therefore, we can apply Case 3. The complexity is $\Theta(n^3)$ by definition. 
4. Since c < 2, $log_a(b) = log_{2}(4) =  2$, $c<log_a(b)$
   Therefore, we can apply Case 1.The complexity is $\Theta(n^2)$ by definition. 
5. Since c > 1, $log_a(b) = log_{8}(4) =  2/3$, $c>log_a(b)$
   Therefore, we can apply Case 3.The complexity is $\Theta(f(n))$ by definition. 
# Question 4
1. [1, 2, 3, 4, 6, 5, 7, 10] **Insertion sort** is very efficient for almost sorted lists. It can sort the small inconsistent with a minimal cost. 
   Space complexity: $O(1)$; 
   Time complexity: $O(n)$ for best case(almost sorted list here);
2. [13, 12, 9, 6, 5, 4, 3, 2, 1] Merge sort does not change the big O complexity for all the orders which maintains $O(nlogn)$. Therefore, it can be used to sort this from high to low order list. 
   Space complexity: $O(n)$; 
   Time complexity: $O(nlogn)$ (For all cases);
3. [1, 10, 5, 8, 3, 9, 6, 4, 2] Quick sort have a average of $nlogn$ time complexity. It is best for random level sorting. Also, it takes less space than Merge sort which also have an average $nlogn$ time complexity. 
   Space complexity: $O(log(n))$; 
   Time complexity: $O(nlog(n))$; (For the random average case)
4. [6, 5, 6, 5, 9, 11, 1, 23, 7] Two objects with the same values need to preserve their order after sorting. 
   Bubble sort have a stable condition which when comparing the two elements [Does not switch elements if they are equal](https://docs.google.com/presentation/d/1ShQZOk9PiYynkVtGClzpCDPlaZmy7eyoFkgW4gkSN4M/edit#slide=id.p19). Therefore, it satisfies the requirement. 
   Space complexity: $O(1)$; 
   Time complexity: $O(n^2)$ (For the random average case)
5. [(3, 9), (4, 5), (4, 4), (9, 5), (8, 7), (10, 6)] where each tuple (key, value) is sorted by the key. The ordering of the values must be preserved where the keys are equivalent.
   The reason is the same as above. 
   Space complexity: $O(1)$; 
   Time complexity: $O(n^2)$ (For the random average case)
# Question 5 
## Explanation
The question given is a undirected graph. 
We assign the start vertex as A as the question required. Therefore, we can see the distances from the starting point to A's neighbours, B and C are 17 and 47 separately, and other distances here would be considered as infinity. The lowest distance go to the next unvisited point would be current distance add the distance from A to B, which is 17.  
Then, we assign B as the current vertex, and we know the current distance is 17 from the starting point to B. Then we can calculate the distance from the starting point to B's neighbours D and E are 28 and 24. We compare all unvisited points that has a non-infinity distance including C, D and E. And all other points remains infinity from the starting point. Therefore, we can determine the next point is E. 
By keep doing this, we can observe the result by connecting D, F and C respectively. 
## Result
![[Drawing 2023-11-21 14.11.59.excalidraw]]
![[Drawing 2023-11-21 14.11.59.excalidraw 1]]
![[Drawing 2023-11-21 14.11.59.excalidraw 1 1]]
![[Drawing 2023-11-21 14.11.59.excalidraw 1 1 1]]
![[Drawing 2023-11-21 14.11.59.excalidraw 1 1 1 1]]
![[Drawing 2023-11-21 14.11.59.excalidraw 1 1 1 1 1 ]]
# Question 6
## Explanation
The question given is a directed graph. 
Similar to the previous question, we assign the start vertex as A. Therefore, we can see the distance from the starting point to A's neighbour B is 13, and other distances here would be considered as infinity. The lowest distance go to the next unvisited point would be current distance add the distance from A to B, which is 13.   
Then, we assign B as the current vertex, and we know the current distance is 13 from the starting point to B. Then we can calculate the distance from the starting point to B's neighbours E is 28. We compare all unvisited points that has a non-infinity distance, which only have E in this case. And all other points remains infinity from the starting point. Therefore, we can determine the next point is E. 
Then, we assign E as the current vertex, and we know the current distance is 13 from the starting point to B. Then we can calculate the distance from the starting point to B's neighbours E is 28. We compare all unvisited points that has a non-infinity distance, which only have E in this case. And all other points remains infinity from the starting point. Therefore, we can determine the next point is E. 
## Result
![[Drawing 2023-11-21 14.49.43.excalidraw]]
![[Drawing 2023-11-21 14.49.43.excalidraw 1]]
![[Drawing 2023-11-21 14.49.43.excalidraw 1 1]]
![[Drawing 2023-11-21 14.49.43.excalidraw 1 1 1]]
![[Drawing 2023-11-21 14.49.43.excalidraw 1 1 1 1]]
![[Drawing 2023-11-21 14.49.43.excalidraw 1 1 1 1 1]]
# Question 7
## Question a. 
### Table
|Stage| V | E |
|----|------------|------------|
|0|(A)|()|
|1|(A,B)|((A,B))|
|2|(A,B,C)|((A,B),(B,C))|
|3|(A,B,C,G)|((A,B),(B,C),(C,G))|
|4|(A,B,C,D,G)|((A,B),(B,C),(C,G),(B,D))|
|5|(A,B,C,D,G)|((A,B),(B,C),(C,G),(B,D))|
|6|(A,B,C,D,E,G)|((A,B),(B,C),(C,G),(B,D),(D,E))|
|7|(A,B,C,D,E,F,G)|((A,B),(B,C),(C,G),(B,D),(D,E),(E,F))|
### Explanation
## Question b. 
### Table
|Stage| Edges | Components| E |
|----|------------|------------|------------|
|0|((A,B),(B,C),(A,C),(B,D),(B,E),(C,E),(E,F),(C,G),(G,F))|((A),(B),(C),(D),(E),(F),(G))|()|
|0|((A,B),(B,C),(A,C),(B,D),(B,E),(C,E),(C,G),(G,F))|((A),(B),(C),(D),(E,F),(G))|((E,F))|
|0|((A,B),(A,C),(B,D),(B,E),(C,E),(C,G),(G,F))|((A),(B,C),(D),(E,F),(G))|((E,F),(B,C))|
|0|((A,B),(A,C),(B,D),(B,E),(C,E),(G,F))|((A),(B,C),(D),(E,F,G))|((E,F),(B,C),(C,G))|
|0|((A,C),(B,D),(B,E),(C,E),(G,F))|((D),((A,B,C,E,F,G))|((E,F),(B,C),(C,G),(A,B))|
|0|((A,C),(B,E),(C,E),(G,F))|((A,B,C,D,E,F,G))|((E,F),(B,C),(C,G),(A,B),(B,D))|

### Explanation

# Question 8
```
Algorithm 2 RIGHT-ROTATE(T, x)
Require: x.left ≠ T.nil, T.root.p == T.nil
1: y = x.left // set y
2: x.left = y.right // turn y’s right subtree into x’s left subtree
3: if y.right ≠ T.nil then
4:    y.right.p = x
5: end if
6: y.p = x.p // link x’s parent to y
7: if x.p == T.nil then
8:    T.root = y
9: else if x == x.p.right then
10:   x.p.right = y // link y to be the right child of x’s parent
11: else
12:    x.p.left = y
13: end if
14: y.right = x // put x on y’s right
15: x.p = y
```
# Question 9
See attached Python file. 